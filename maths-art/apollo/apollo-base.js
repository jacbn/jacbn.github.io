import * as bc from '../../modules/basicCanvas.js';
import Complex from '../../modules/basicComplex.js';

var canvas = document.getElementById("mainCanvas");
var ctx = canvas.getContext("2d");
ctx.setTransform(1, 0, 0, -1, canvas.width/2, canvas.height/2);

const OUTER_CIRCLE_SIZE = -240;
const RATIO = 0.5;
const ITERATIONS = 5;

/*
some things to improve the program:

    - balance the detail on all sides -- i.e. don't continue recursing
      past a certain depth until everywhere in the shape has reached said
      depth
    - detail limits

*/


const START_SIZE = -OUTER_CIRCLE_SIZE*RATIO;
var largestRadius = 0;
var circles = {};
/*
    circles {}:
        key is a pairing (cantorPairing) of a circle's x and y coordinate.

        contains a mapping from one circle to the three circles it is 
        generated by.

        used for:
            - when deciding which circles to use to generate a fourth,
              consider only sets of three circles, one of which from 
              the most recent generation.
                - i.e. iterate through all pairs of the most recent 
                  generation's connections, gen circle with the new one
                  and each pair. note that each time we do this, one of
                  the generated circles will be the 4th that we didn't
                  pick -- ignore.
*/


class Circle {
    /**
     * Defines a circle on the complex plane.
     * @param {Complex} centre The centre of the circle.
     * @param {Number} r The radius of the circle.
     * @param {Boolean} initial True if the circle is one of the three starting circles.
     */
    constructor(centre, r, initial=false) {
        this.x = centre.re;
        this.y = centre.im;
        this.exists = false;

        this.id = cantorPairing(Math.round(this.x), Math.round(this.y));
        if (this.id in circles) {
            //console.log("REPEAT CIRCLE: ", this.x, this.y);
            delete this;
            return;
        }

        this.exists = true;
        this.centre = centre;
        this.r = r;
        this.c = 1/r;
        if (!initial && this.r > largestRadius) {
            largestRadius = this.r;
        }
        
    }

    draw() {
        bc.drawCircle(ctx, this.x, this.y, this.r);
    }
}




//const a = new Circle(new Complex(OUTER_CIRCLE_SIZE+START_SIZE, 0), START_SIZE);
//const b = new Circle(new Complex(START_SIZE, 0), -OUTER_CIRCLE_SIZE-START_SIZE);
//const c = new Circle(new Complex(0, 0), OUTER_CIRCLE_SIZE);

//const a = new Circle(new Complex(-40, 30), 50);
//const b = new Circle(new Complex(4.323758872438418, 81.61224384175775), 18.045290840985853);
//const c = new Circle(new Complex(0, 0), -100);

const a = new Circle(new Complex(-50, 0), 50, true);
const b = new Circle(new Complex(-50, -66.66666666666), 16.666666666666, true);
const c = new Circle(new Complex(0, 0), -100, true);

a.draw();
b.draw();
c.draw();

const origCircles = [a,b,c];


circles[a.id] = [b, c];
circles[b.id] = [a, c];
circles[c.id] = [a, b];

iterate(ITERATIONS, origCircles);

function cantorPairing(x, y) {
    const a = (x < 0) ? -2*x - 1 : 2*x;
    const b = (y < 0) ? -2*y - 1 : 2*y;
    return Math.floor(0.5*(a+b)*(a+b+1)+b);
}

function getPosition(circle1, circle2, circle3, reverse=false) {
  
    const r4 = calcRadius(circle1.c, circle2.c, circle3.c, reverse);

    const [c1p1, c2p2, c3p3] = [circle1.centre.scale(circle1.c), circle2.centre.scale(circle2.c), circle3.centre.scale(circle3.c)];
    
    const [L, R] = 
    [
        c1p1.add(c2p2).add(c3p3), 
        Complex.sqrt(c1p1.multiply(c2p2.add(c3p3)).add(c2p2.multiply(c3p3))).scale(2)
    ];


    const p4pos = L.add(R).scale(r4);
    const p4neg = L.sub(R).scale(r4);
    var p4;


    if (reverse) {
        p4 = (p4pos.sqabs <= p4neg.sqabs) ? p4pos : p4neg;
    } else {
        p4 = (p4pos.sqabs > p4neg.sqabs) ? p4pos : p4neg;
    }

    const out = new Circle(p4, r4);
    circles[out.id] = [circle1, circle2, circle3];
    return out;

}


function calcRadius(c1, c2, c3, reverse) {
    //formula is 1/(c1 + c2 + c3 +/- 2 * math.sqrt(abs(c1*c2 + c2*c3 + c3*c1)));
    //the negative form is used for circles with larger radii than the three given.
    const [L, R] = [c1+c2+c3, 2*Math.sqrt(Math.abs(c1*(c2+c3)+c2*c3))];

    //.py script just stops here if reverse && largestCircle.r < 180??
    return (reverse) ? 1/(L-R) : 1/(L+R);
}


function generate(c1, c2, c3) {
    var circle, second;
    circle = getPosition(c1, c2, c3); //replace reverse with getBoth
    circle.draw();                    //so only 1 call needed here
    if (largestRadius <= 180) { //&& circle.exists; seems to work fine w/ no if
        second = getPosition(c1, c2, c3, true);
        second.draw();
    } 
    return [circle, second];
}

/*function iterate() {
    for (var c1 of circles) {
        for (var c2 of circles[c1.id]) {
            //c2 goes through each of the 3 kissing circles of c1
            const intersection = difference(intersect(circles[c1.id], circles[c2.id]), [c1]);

            for (var c3 of intersection) {

            }
        }
    }
}*/

function iterate(iters, newCirclesFromLastIteration) {
    var connections = [];
    var newCircles = [];
    var processed = [];
    for (var c of newCirclesFromLastIteration) {
        connections = difference(circles[c.id], processed);
        const pairs = getPairs(connections);
        for (var pair of pairs) {
            const gen = generate(c, pair[0], pair[1]);
            console.log(gen);
            for (var g of gen) {
                if (g !== undefined && g.exists) {
                    newCircles.push(g);
                }
            }
        }
        processed.push(c);
    }
    console.log("ITERATION " + (ITERATIONS - iters + 1) + ": ", newCircles)

    if (iters > 1) {
        iterate(iters-1, newCircles);
    }

}



//might just be better to output the 6 pairs directly rather than calculate
//them each time? idk
function getPairs(l) {
    var out = [];
    for (var i = 0; i < l.length; i++) {
        for (var j = i+1; j < l.length; j++) {
            out.push([l[i], l[j]]);
        }
    }
    return out;
}


function difference(a, b) {
    return a.filter(function(i) {return b.indexOf(i) < 0;});
}